### 泛型的使用
1. 没有使用泛型：
   1. 任何Object及其子类对象类型都可以添加进Collection
   2. 遍历过程中会有ClassCastException异常抛出
2. 在集合中使用使用泛型
3. 自定义泛型类、泛型接口、泛型方法
4. 泛型和继承的关系
5. 通配符

##### 自定义泛型类
1. 当实例化泛型类的对象时，指明泛型的类型，指明以后，对应的类中所有使用泛型的位置，都替换为实例化中指定的泛型类的类型
2. 如果自定义了泛型类，但是在实例化时没有使用，那么默认类型是Object
3. 继承泛型类或泛型接口时，可以指明泛型的类型
4. 泛型方法：当通过对象调用泛型方法时，指明泛型方法的类型，
```java
public <E> e getE(E e) {
    return e;
}
```

##### 泛型与继承的关系
若类A是类B的子类，那么`List<A>`不是`List<B>`的子类

##### 通配符 ?
`List<A> List<B> ...`都是List<?>的子类

`<? extends E>`：可以存放E的类型或E的子类

`<? super E>`：可以存放E的类型或E的父类

静态方法中不能使用类的泛型：实例化的过程中才能确定泛型的类型，而静态成员在类加载时加载

catch中不能使用泛型：catch捕获异常的原则是子类在前，而泛型会产生矛盾

可以读取声明为通配符的集合类的对象     
不允许向声明为通配符的集合类(任何类)中写入对象，除了null
