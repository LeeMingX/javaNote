### 设计模式
解决问题的思考方式     
23种设计模式

##### 单例模式
解决的问题：使得一个类只能创建一个对象      
如何实现(饿汉式)：
1. 私有化构造器，使得类的外部不能够调用此构造器
2. 在类的内部创建一个类的实例
3. 私有化此对象，通过公共的方法来调用
4. 此公共的方法，只能通过类来调用，因此声明为static，此实例也应该声明为static的

##### 单例模式的懒汉式实现
1. 私有化构造器，使得类的外部不能够调用此构造器
2. 在类的内部创建一个类的实例，赋值null
3. 私有化此对象，通过公共的方法来调用
4. 此公共的方法，只能通过类来调用，因此声明为static，此实例也应该声明为static的，在方法中判断该实例是否为null，是则创建一个新的对象，否则返回该对象 

**Note：** 懒汉式实现可能存在线程安全问题

### main()方法的使用
主方法，是程序的入口，同时满足普通静态方法的特点

### 初始化块(代码块)
关于属性赋值的操作：
* 默认的初始化
* 显式地初始化／代码块的初始化
* 构造器中初始化
* 通过方法对对象的相应属性进行修改

代码块只能被static修饰符修饰
1. 静态代码块
   * 可以有输出结构
   * 随着类的加载仅加载一次
   * 多个静态代码块按照顺序结构执行，早于非静态代码块执行
   * 不能对非静态属性赋值／方法，即调用静态结构
2. 非静态代码块
   * 可以对类的属性进行初始化操作，可以调用本类的方法
   * 可以有输出结构
   * 一个类中可以包含多个非静态代码块，多个代码块之间按照顺序结构执行
   * 每创建一个类的对象，非静态代码块就加载一次
   * 代码块早于构造器执行
   * 属性的显式初始化和代码块初始化按照顺序进行

### final关键字
声明类、属性和方法可以用final
1. final修饰类：这个类不能被继承，如String、StringBuffer类、System类
2. final修饰方法：这个方法不能被重写
3. final修饰属性：此属性是一个常量，用大写字母来表示，一旦初始化后不能再被赋值
   * 此常量不能用默认初始化
   * 可以显式地赋值
   * 可以在代码块和构造器中赋值

变量用static final修饰：全局常量

与finally、finalize()有所区分

### 抽象类
修饰类、方法
1. abstract修饰类，抽象类
   * 不可以被实例化
   * 包含构造器(凡是类都有构造器)
   * 抽象方法所在的类是抽象类
   * 抽象类中可以有非抽象方法
2. abstract修饰方法，抽象方法
   * 没有方法体({})，用abstract修饰
   * 只保留方法的功能，具体的实现交给继承抽象类的子类，由子类重写该方法
   * 若子类继承抽象类，并重写了所有的抽象方法，则此类是一个“实体类”，即可以实例化
   * 若子类继承抽象类，没有重写所有的抽象方法，意味着此类中仍有抽象方法，则此类必须声明为抽象的

abstract不能用来修饰属性、构造器(构造器不能被重写)、private、final(修饰的方法不能被重写)、static

##### 模版方法设计模式
解决问题：功能内部一部分实现是确定的，一部分实现是不确定的，这时可以把不确定的部分暴露出去，让子类去实现
 
### interface接口
是与类并行的一个概念    
1. 接口可以看成特殊的抽象类，是常量与抽象方法的集合
   * 所有的常量都用public static final修饰
   * 所有的方法都用public abstract修饰
2. 接口没有构造器
3. 接口定义的是一种功能，此功能可以被类所实现(implements)
4. 实现接口的类，必须要重写所有的抽象方法，才能实例化，不然此类仍为抽象类
5. 类可以实现多个接口
6. 接口与接口之间也是继承关系，接口之间可以多继承