##### 四种权限修饰符
protected：如果子类和父类不在同一个包下，也可以进行方法的重写

##### super关键字
* 访问父类中定义的属性
* 调用父类中定义的成员变量
* 在子类构造方法中调用父类的构造器

当子类与父类中有重名的属性，可以通过“super.属性”显式调用父类中声明的属性，使用“this.属性”调用子类中声明的属性     
在子类中显示地调用父类被重写的方法，需要使用“super.方法”显式调用父类中的方法      
通过在子类中使用“super(形参列表)“来显式调用父类中的指定的构造器    
在构造器内部，”super(形参列表)“需要在首行      
“this(形参列表)”和“super(形参列表)”不能同时出现     
当构造器中不显示调用”super(形参列表)“和“this(形参列表)”的形式，默认调用的是父类空参的构造器

设计一个类时，尽量提供一个空参构造器

##### 子类对象实例化的过程
```
class Creator(age;)
class Animal extends Creator(name;)
class Dog extends Animal(hostName;)

Dog dog = new Dog()
```
先调用父类的构造器，再调用子类的构造器！！

### 面向对象的特性-多态
一个事物的多重表现形态
1. 方法的重载和重写
2. 子类对象的多态性：父类的引用指向子类对象
   * 虚拟方法调用，调用方法时，调用的是子类重写父类的方法
3. 子类对象的多态性使用的前提：
   * 有类的继承
   * 有子类对父类方法的重写
4. 程序运行分为编译状态和运行状态，编译时，引用变量理解为父类的类型，运行时，关注于真正对象的实体，执行的方法是子类重写的方法
5. 子类对象的多态性不适用于属性

instanceof: 格式-> 对象a instanceof 类A，判断对象a是否是类A的一个实例，是返回true，否返回false

### Object类
equals()：java.lang.Object类中的一个方法
1. 只能处理引用类型变量
2. 在Object类中equals()方法依旧比较的是两个对象的地址值是否相等
3. 像String类、包装类、File类、Date类这些重写Object类的equals()方法，比较的是两个对象的“实体内容”是否完全相同
