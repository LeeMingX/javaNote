### 内存模型以及分区
* Java内存区域
   * 线程共享内存区
      * Java堆 -> OutOfMemoryError
      * 方法区 -> OutOfMemoryError
   * 线程私有内存区：随线程产生和消亡，不需要过多考虑内存回收的问题，编译时确定所需内存的大小
      * 虚拟机栈 
         * -> StackOutflowError(单线程)
         * -> OutOfMemoryError(多线程)
      * 本地方法栈 
         * -> StackOutflowError(多线程)
         * -> OutOfMemoryError(多线程)
      * 程序计数器 -> 无内存溢出的异常

##### 每个分区的具体工作
1. 程序计数器(Program Counter Register)    
   一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它实现，每个线程有独立的程序计数器，各线程的计数器互不影响，因此该区域是线程私有的。    
   当线程在执行一个Java方法时，计数器记录的是正在执行的虚拟机字节码指令的地址，当线程执行的是Native方法时，该计数器的值为空。    
   该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM(OutOfMemoryError)情况的区域
2. Java虚拟机栈(Java Virtual Machine Stacks)    
   该区域也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的同时会创建一个栈帧，栈是用来支持虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有指令都针对与当前栈帧进行操作。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译代码时，栈帧中需要多大的局部变量表、多深的操作栈都已经完全确定了，并且写入了方法表的Code属性中。    
   因此，一个栈帧需要分配多少内存，不会受到程序运行期间变量数据的影响，而仅仅取决于具体的虚拟机实现。
3. 本地方法栈      
   与虚拟机栈的作用相似，为使用到的本地操作系统(Native)方法服务
4. Java堆      
   Java Heap时Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域，几乎所有对象实例和数组都在这里分配内存。Java Heap是垃圾收集器管理的主要区域，也被称为“GC堆”。    
   根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可以分配且堆野无法扩展时，会抛出OOM异常
5. 方法区      
   方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区又被称为“永久代”。**Java8之后移除了永久代**     
   Java虚拟机规范把方法区描述为Java堆的一个逻辑部分，它与Java Heap一样不需要连续的内存，可以选择固定大小或可扩展，虚拟机规范允许该区域可以选择不进行垃圾回收。相对而言，垃圾收集行为在此区域比较少出现。该区域的内存回收目标主要针对废弃常量和无用类的回收。运行时常量池是方法区的一部分，class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项class文件常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。      
   运行时常量池相对于class文件常量池的重要特征是具备动态性，Java语言不要求常量一定只能在编译期产生，即并非预置入class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被利用较多的是String.intern()方法。      
   根据Java虚拟机规范，当方法区无法满足内存分配需求时，将抛出OOM异常。

##### 内存泄漏和内存溢出的差别
内存泄漏：内存泄漏是指分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费。Java中由于有垃圾回收器自动回收垃圾，一般不会出现内存泄漏问题。       
内存溢出：指程序所需要的内存超出了系统所能分配的内存(包括动态扩展)的上限

