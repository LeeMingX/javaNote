### 多线程
线程：程序的一条执行路径

创建多线程的方式
1. 继承java.lang.Thread
   1. 创建一个继承于Thread的子类
   2. 重写Thread类的run()方法，方法内实现此子线程要完成的功能
   3， 创建一个子类的对象
   4. 调用线程的start()方法
      * 启动此线程
      * 调用run()方法
2. 通过实现Runnable接口的方式 
   1. 创建一个实现了Runnable接口的类
   2. 实现接口的抽象方法
   3. 创建一个Runnable接口实现类的对象
   4. 将此对象作为形参传递给Thread类的构造器中，创建Thread类对象，此对象即为一个线程
   5. 调用start()方法，启动线程并执行run()

**Note：** 一个线程只能执行一次start()方法，不能通过Thread的子类对象调用run()方法来启动线程

Thread的常用方法
1. start()：启动线程并执行相应的run()方法
2. run()：子线程要执行的代码放入run()方法
3. currentThread()：静态的调取当前的线程
4. getName()：获取此线程的名字
5. setName()：设置此线程的名字
6. yield()：调用此方法的线程强制释放当前CPU的执行权
7. join()：在A线程中调用B线程的join()方法，表示当执行到此方法，A线程停止执行，直至B线程执行完毕，A线程再接着join()之后的代码
8. isAlive()：判断当前线程是否存活
9. sleep(long millSecond)：显式地让当前线程睡眠 - 毫秒
10. wait() notify() notifyAll() 有关线程通信

设置线程的优先级
1. getPriority()：返回线程优先级
2. setPriority(int newPriority)：改变线程的优先级

继承方式与实现方式做比较
1. 联系：public class Thread implements Runnable
2. 对比：实现过程避免了java中单继承的局限性，如果多个线程操作一个资源，实现方式不需要声明静态变量

线程安全问题存在的原因：由于一个线程在操作共享数据中，未执行完毕的情况下，另外的线程参与进来，导致共享数据存在了安全问题

如何解决线程的安全问题：必须让一个线程操作共享数据完毕之后，其他线程才有机会参与共享数据的操作

##### 线程的同步机制
方式一：同步代码块
```
synchronized(对象／同步监视器) {
	//需要被同步的代码（操作共享数据的代码）
}
```
1. 共享数据：多个线程共同操作的同一个数据，即变量
2. 同步监视器(锁／this)，由一个类的对象来充当，获取此监视器的线程执行代码块中的代码，this表示当前对象。继承的方式中要慎用this

方式二：同步方法      
将操作共享数据的方法声明为synchronized，即此方法为同步方法，能够保证当其中一个线程执行此方法时，其它线程等待至此线程执行完此方法。同步方法的锁：this

线程同步的弊端：由于同一时期内只能有一个线程访问共享数据，效率变低

##### 死锁问题
不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁

设计阶段应该避免死锁问题

##### 线程通信
1. wait()：挂起线程，一个线程执行到wait()，释放当前锁
2. notify()：唤醒队列中优先级最高的线程
3. notifyAll()：唤醒所有线程

**Note：** 只能在synchronized代码块和synchronized方法中使用

